general:

- Llevar cosas que sacamos del kyg a lib.rs y desde ctehexml
    - extraer muros del ctehexml (ahora solo salen los de la ET y no, p.e. los interiores)
    - consultar solo datos de kyg en lib.rs, mientras que no los calculemos nosotros (p.e. Fshobst, U)
- Ir viendo qué cosas se podrían sacar del BDL en lugar del kyg (el tbl ya no se usa)
    - Primero detectar elementos en BDL y tomar datos de kyg hasta que no se calculen
- Incluir espacios en la exportación y detectar elementos de la envolvente a partir de ellos
- Incluir construcciones en la exportación
    - opacos
    - huecos
    - pts?
- Añadir tests de tbl.rs (parse)
- Convertir vectores de objetos de espacios, pisos, etc a vectores de nombres y hashmaps de objetos
  o convertir a https://docs.rs/crate/indexmap/

ideas:
- Se podría eliminar la referencia entre muros y espacios, generando el polígono del muro a partir de su referencia al polígono del espacios
    - así eliminamos referencias a vértices de polígonos y también location
- Se podrían meter las ventanas como hijos de muros para facilitar las mediciones (pero tiene sus desventajas)
- hacer visualizador 3d (con 3djs).


envolventectedata:
    Llevar a env:
        - Altura libre de espacios: data.space_net_height(spacename)
            - Otra opción es llevar la altura de suelo a techo al espacio como dato
        - Volumen neto de espacios: data.space_volume(spacename)
        - ir viendo los cálculos que hacemos cómo se pueden llevar de BDL a envolventetypes eliminando aspectos innecesarios
            wall -> data.wall_gross_area(wallname), data.wall_net_area(wallname), data.wall_azimuth(wallname)
            ...
        - Volumen interno a la envolvente térmica: volumen_et
        - K (igual devuelve estructura con datos intermedios por tipos, área de intercambio, etc)

BDL:
- Quitar de los elementos aquellas cosas que necesitan consultas globales (con acceso a bdldata)
- Comprobar qué se cambia en las plantas o en el edificio cuando se indica una cota base distinta a la 0.0 (ver si se pone la Z de la planta P01 distinta a "")
- Convertir definición de muros de polygon o location a (X, Y, Z, WIDTH, HEIGHT, AZIMUTH)
- Implementar espacios (y plantas) con multiplicadores (mediciones)
- Seguir eliminando bloques genéricos convirtiendo a estructuras los elementos BDL:
    - metadatos
    - horarios
    - condiciones operacionales
    - consignas
- Hacer cálculos de:
    - Para azimut e inclinación ver 52016-1
    - posiciones de cerramientos y nombre orientación (que es respecto al sur y no al norte, como tenemos ahora)
            if hasattr(self, 'LOCATION'):
                lugar = getattr(self, 'LOCATION')
                if lugar == 'BOTTOM':           posicion = 'suelo'
                elif lugar == 'TOP':            posicion = 'techo'
                elif lugar.startswith('SPACE'): posicion = 'muro'
                else: raise
            elif hasattr(self, 'TILT'): #si no tiene location debe tener tilt, y se corrigen los de space
                tilt = float(getattr(self, 'TILT'))
                if tilt < 60:      posicion = 'techo'
                elif tilt < 120:   posicion = 'muro'
                elif tilt < 240:   posicion = 'suelo'
                else: raise
            else: raise
- Implementar cálculo de U para los distintos elementos y así no usar kyg
  (O al menos calcular con suma de las resistencias superficiales)

EnvolventeCTE:
- Eliminar uso de data.autil y usar data.a_util_ref()
- Leer datos de gglshwi desde construcción de hueco y no en el elemento
- Exportar construcciones (LAYERS, GAPS)
